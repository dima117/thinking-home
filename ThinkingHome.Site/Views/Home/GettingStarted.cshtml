@{
	ViewBag.Title = "С чего начать?";
	ViewBag.Name = "GettingStarted";
	Layout = "~/Views/Shared/Layout.cshtml";
}

<div class="row">
	<div class="col-md-12">

		<h1>Базовые возможности</h1>
		<h2>Разработка плагинов</h2>
		<h3>Логирование</h3>
		<p>
			Логирование - самый простой способ получить информацию из плагина. Базовый класс
			<code>ThinkingHome.Core.Plugins.Plugin</code> содержит объект <code>Logger</code>,
			при помощи методов которого можно записывать сообщения в лог.
		</p>
		<pre>
	Logger.Info("Hello, world!");
</pre>
		<p>
			По умолчанию лог сохраняется в текстовый файл в папке "Log". Для каждого плагина
			создается 
			отдельный файл,	имя которго соответствует названию плагина. Также лог делится
			по датам 
			(лог за каждый день сохраняется в отдельном файле).  
		</p>
		<p>
			Для логирования в системе используется библиотека NLog. Настройки логирования
			можно задать в конфигурационном файле приложения (файл ThinkingHome.Service.exe.config
			в корневой директории сервиса). Например, можно настроить, чтобы ошибки сохранялись
			в БД
			или отправлялись на e-mail.
		</p>
		<h3>Вызов команд других плагинов</h3>
		<p>
			Каждый плагин - это класс .NET, содержащий некоторый функционал. Из любого плагина
			можно 
			получить экземпляр любого другого плагина и вызывать его открытые (public) методы.
			Например,
			ваш плагин может получить экземпляр плагина, управляющего освещением через noolite
			и вызвать 
			у него метод выключения света в заданном канале.
		</p>
		<p>
			Получить экземпляр другого плагина можно получить через свойство Context базового
			класса 
			<code>ThinkingHome.Core.Plugins.Plugin</code>. Это свойство содержит объект, реализующий
			интерфейс <code>ThinkingHome.Core.Plugins.IServiceContext</code>. Для получения
			экземпляра 
			другого плагина используйте метод <code>GetPlugin&lt;TPlugin></code>. Перед этим
			необходимо
			добавить в проект вашего плагина ссылку на сборку, в которой находится используемый
			плагин.
		</p>
		<pre>
	var noolitePlugin = Context.GetPlugin&lt;NooLitePlugin>(); 
	noolitePlugin.SetLevel(50, 3); // устанавливаем уровень яркости 50 в третьем канале
</pre>
		<p>
			Метод <code>GetAllPlugins</code> возвращает коллекцию всех плагинов, доступных в
			приложении.
		</p>
		<pre>
	// вывод в лог названий всех доступных плагинов  
	foreach (var plugin in Context.GetAllPlugins())
	{
		var typeName = plugin.GetType().Name;
		Logger.Info(typeName);
	}
</pre>
		<h3>Подписка на события плагинов</h3>
		<p>
			Плагины могут подписываться на события других плагинов. Например, плагин "будильник"
			может подписаться на событие "срабатывание таймера" плагина "таймер" и, если наступило
			нужное время, подать звуковой
			сигнал.
		</p>
		<p>
			Плагин, генерирующий событие, определяет у себя коллекцию делегатов - обработчиков
			события. Другие плагины объявляют у себя методы-обработчики для заданного события
			и связывают их с коллекцией делегатов. Связывание происходит при помощи MEF
			(т.е. коллекция обработчиков и сами обработчики события помечаются специальными
			атрибутами).
		</p>
		<p>
			Для того, чтобы разрешить другим плагинам подписываться на событие, нужно определить
			коллекцию делегатов с нужными параметрами и отметить ее атрибутом 
			<code>System.ComponentModel.Composition.ImportManyAttribute</code>. Для того, чтобы
			в список обработчиков добавлялись только нужные обработчики, а не все методы с такой
			же сигнатурой (такими же типами параметров и возвращаемого значения), укажите для
			атрибута ImportMany уникальный идентификатор (например, сгенерируйте Guid). Ниже
			приведен пример описания коллекции обработчиков для события "срабатывание таймера"
			плагина "таймер" (он генерирует событие "срабатывание таймера" каждые 30 секунд).
		</p>
		<pre>
	[ImportMany("E62C804C-B96B-4CA8-822E-B1725B363534")]
	public Action&lt;DateTime>[] OnEvent { get; set; }
</pre>
		<p>
			Теперь другие плагины могут создавать обработчики для этого события. Сигнатура обработчика
			события задается типом элемента коллекции обработчиков. В нашем примере тип элемента
			- 
			<code>Action&lt;DateTime></code>, значит, обработчик события должен принимать один
			параметр типа <code>DateTime</code> (текущее время) и не возвращать никакого значения
			(void).
		</p>
		<p>
			Ниже приведен пример обработчика события "срабатывание таймера", который включает
			будильник,
			если настал установленный момент времени.
		</p>
		<pre>
	public void OnTimerElapsed(DateTime now)
	{
		var alarmTime = now.Date.AddHours(8).AddMinutes(15);	// время звонка будильника - 8:15
			
		if (now >= alarmTime &&                        // если пришло время звонка будильника
		    now < alarmTime.AddMinutes(5) &&           // и еще не прошло 5 минут
		    lastAlarmTime < alarmTime)                 // и будильник сегодня еще не звонил
		{
			lastAlarmTime = now;
			Context.GetPlugin&lt;SoundPlugin>().PlayAlarmSound();
		}
	}
</pre>
		<p>
			Для того, чтобы этот метод попал в коллекцию обработчиков события, нужно пометить
			его 
			атрибутом <code>System.ComponentModel.Composition.ExportAttribute</code>	и указать
			в его параметрах
			тот же самый идентификатор, который был указан в атрибуте ImportMany (у коллекции
			обработчиков).
		</p>
		<pre>
	[Export("E62C804C-B96B-4CA8-822E-B1725B363534")]
	public void OnTimerElapsed(DateTime now)
	{
		...
	}
</pre>
		<p>
			Для более удобной подписки на события (без необходимости указывать идентификатор)
			можно создать
			собственный атрибут, унаследованный от <code>System.ComponentModel.Composition.ExportAttribute</code>
			и передать нужный идертификатор при вызове базового конструктора.
		</p>
		<pre>
	// собственный атрибут												 
	[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
	public class OnTimerElapsedAttribute : ExportAttribute
	{
		public OnTimerElapsedAttribute()
			: base("E62C804C-B96B-4CA8-822E-B1725B363534")
		{  
		}
	}		
	   
	...
	
	// подписка на событие
	[OnTimerElapsed]
	public void OnTimerElapsed(DateTime now)
	{
		...
	}
</pre>
		<p>
			Итак, мы пометили нужными атрибутами коллекцию делегатов и необходимые методы плагинов.
			При старте сервиса указатели на нужные методы автоматически будут добавлены в коллекцию
			делегатов. После этого остается только вызвать все подписанные методы при возникновении
			нужного события.
		</p>
		<p>
			Для вызова обработчиков события лучше всего воспользоваться методом <code>Run</code>
			из 
			базового класса плагина. В качестве параметров передается сама коллекция делегатов
			и 
			лямбда-выражение, задающее действие над каждым из них (т.е. вызов делегата с нужными
			параметрами). Внутри метод Run проходит в цикле по всем обработчикам и вызывает
			для каждого
			из них выражение, переданное во втором параметре (с обработкой исключений).
		</p>
		<p>
			Пример, приведенный ниже - из плагина "таймер": при срабатывании системного таймера
			вызываются все подписанные обработчики, в каждый из которых передается текущие дата
			и время.
		</p>
		<pre>
	[ImportMany("E62C804C-B96B-4CA8-822E-B1725B363534")]
	public Action&lt;DateTime>[] OnEvent { get; set; }

	public override void Init()
	{
		timer = new System.Timers.Timer(TIMER_INTERVAL);
		timer.Elapsed += OnTimedEvent;
	}

	private void OnTimedEvent(object source, ElapsedEventArgs e)
	{
		var now = DateTime.Now;
		Run(OnEvent, x => x(now));
	}
</pre>
		<h2>Доступ к системной БД</h2>
		<p>
			Плагины могут хранить свои данные в системной БД. Например, плагин "будильник" может
			хранить там список настроек будильников.
		</p>
		<h3>Создание таблиц</h3>
		<p>
			Плагины могут автоматически создавать себе необходимые таблицы в БД. Для этого используется
			ECM7.Migrator - инструмент контроля версий БД. С его помощью можно описать
			"миграции" - небольшие порции изменений БД. Каждая миграция имеет номер версии, в которой
			будет находиться БД после ее применения. Мигратор 
			автоматически выполняет миграции в нужной последовательности. При старте сервиса выполняются 
			миграции, описанные в плагинах и автоматически создаются все нужные объекты БД.
		</p>
		<p>
			Каждая "миграция" - это класс на .NET, унаследованный от базового класса 
			<code>Migration</code> (нужно добавить ссылку на сборку <code>ECM7.Migrator.Framework.dll</code>) 
			и реализующий его абстрактные <code>Apply</code> и <code>Revert</code>.
			В этих методах при помощи специального API описываются изменения БД, необходимые для
			перехода к следующей версии и для отката к изначальной версии. Номер версии задается
			с помощью атрибута <code>MigrationAttribute</code>.
		</p>
		<p>
		</p>
		<pre>
[Migration(1)]
public class Migration01UserScriptTable : Migration
{
	public override void Apply()
	{
		Database.AddTable("Scripts_UserScript",
			new Column("Id", DbType.Guid, ColumnProperty.PrimaryKey, "newid()"),
			new Column("Name", DbType.String.WithSize(200), ColumnProperty.NotNull),
			new Column("Body", DbType.String.WithSize(int.MaxValue), ColumnProperty.NotNull)
		);
	}

	public override void Revert()
	{
		Database.RemoveTable("Scripts_UserScript");
	}
}
</pre>
		<p>
			Внимание, сборка с плагином <strong>обязательно</strong> должна быть помечена атрибутом
			<code>MigrationAssembly</code>, в параметрах которого должно быть указано уникальное 
			"пространство имен" для миграций (в качестве "пространства имен" рекомендуется использовать
			имя сборки). Это нужно, чтобы изменения из разных плагинов выполнялись независимо друг от друга.
			Например:
		</p>
		<pre>
[assembly: MigrationAssembly("ThinkingHome.Plugins.Scripts")]
</pre>
		<h3>Модель данных</h3>
		<p>
			Работа с БД происходит с помощью ORM NHibernate. Инфраструктуру для доступа к данным
			ядро системы инициализирует самостоятельно. В плагине остается только определить классы
			модели данных и настроить мэппинг полей классов на поля таблиц.
		</p>
		<p>
			Для настройки мэппинга переопределите в своем плагине виртуальный метод <code>InitDbModel</code>.
			В качестве входного параметра этот метод получает экземпляр классса <code>NHibernate.Mapping.ByCode.ModelMapper</code>.
			Вызывая его методы, можно полностью настроить мэппинг для собственной модели. Например,
			плагин "Scripts" использует примерно такую модель данных:
		</p>
		<pre>
public class ScriptEventHandler
{
	public virtual Guid Id { get; set; }
	...
}

[Plugin]
public class ScriptsPlugin : Plugin
{
	public override void InitDbModel(ModelMapper mapper)
	{
		<strong>mapper.Class&lt;ScriptEventHandler>(cfg => cfg.Table("Scripts_UserScript"));</strong>
		...
	}	
	...
}
</pre>
		<p>
			По умолчанию при мэппинге действуют следующие правила наименования:
		</p>
		<ul>
			<li>Свойство класса, содержащее идентификатор, должно называться "Id" 
				и будет сохраняться в поле "Id" в таблице БД;
			</li>
			<li>Все свойства мэппятся на поля с таким же названием;</li>
			<li>Свойства, содержащие ссылки на другие сущности, мэппятся на поля с названием
				&lt;название свойства> + "Id".
			</li>
		</ul>
		<p>Например:</p>
		<pre>
public class ScriptEventHandler
{
	// будет связано с полем <strong>"Id"</strong>
	public virtual Guid <strong>Id</strong> { get; set; }

	// будет связано с полем <strong>"PluginAlias"</strong>
	public virtual string PluginAlias { get; set; }

	// будет связано с полем <strong>"EventAlias"</strong>
	public virtual string EventAlias { get; set; }

	// будет связано с полем <strong>"UserScriptId"</strong>
	public virtual <strong>UserScript</strong> UserScript { get; set; }
}
</pre>
		<p>
			В большинстве случаев, мэппинг полей может происходить по этим правилам автоматически.
			Если необходимо настроить более сложный мэппинг, воспользуйтесь методами объекта <code>ModelMapper</code>.
		</p>
	</div>
</div>

