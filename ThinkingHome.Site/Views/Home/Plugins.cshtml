@{
	ViewBag.Title = "Создание плагинов";
	ViewBag.Name = "Plugins";
	Layout = "~/Views/Shared/Layout.cshtml";
}

<div class="container">
	<div class="row">
		<div class="col-md-12">
			<h1>Создание плагинов</h1>
			<p>
				Весь функционал системы реализован в виде плагинов (модулей). Даже такие базовые возможности
				как поддержка сценариев и обработка HTTP запросов - это отдельные плагины (если очень
				захотеть, система будет работать и без них).
			</p>
			<p>
				Вы можете написать собственные плагины и подключить их к системе. Сделать это очень
			легко. 
			При помощи собственных плагинов можно выполнять любые действия, которые может выполнять
			компьютер
			(взаимодействовать с любым оборудованием, получать и отправлять данные через Интернет
			и еще 
			много всего интеренсого).
			</p>
			<p>
				По сути, плагин - это класс .NET, написанный по некоторым правилам. Этот класс нужно скомпилировать в
				файл .dll и скопировать в папку для плагинов. Сервис при старте загрузит ваш плагин
				и в нужные моменты будет запускать логику, которая в нем реализована.
			</p>
			<p>
				Для создания собственного плагина необходимо выполнить 5 простых шагов:
			</p>
			<ol>
				<li>Создать проект в любой IDE и добавить в него ссылку на библиотеку ThinkingHome.Core.Plugins.
				Бесплатные IDE типа Visual Studio Express и SharpDevelop вполне подойдут.
				</li>
				<li>Создать класс и пометить его атрибутом <code>[ThinkingHome.Core.Plugins.PluginAttribute]</code>;
				</li>
				<li>Унаследовать созданный класс от базового класса <code>ThinkingHome.Core.Plugins.Plugin</code>
					и реализовать его абстрактные методы <code>void Init()</code> (инициализация), 
				<code>void Start()</code> (выполняется при запуске сервиса, когда все плагины уже
				инициализорованы) 
				и <code>void Stop()</code>  (выполняется при остановке сервиса).
				</li>
				<li>Реализовать нужную логику плагина.
					<p>...</p>
				</li>
				<li>PROFIT!!!</li>
			</ol>
			<p>
				Ниже приведен пример простого плагина. Как видите, это, действительно, очень просто.
			</p>
			<pre>
	[Plugin]
	public class ExamplePlugin : Plugin
	{
		private System.Timers.Timer timer;

		public override void Init()
		{				 
			timer = new System.Timers.Timer(30000);
			timer.Elapsed += OnTimedEvent;
		}

		public override void Start()
		{			 
			timer.Enabled = true;
		}

		public override void Stop()
		{					   
			timer.Enabled = false;
		}
						   
		private void OnTimedEvent(object source, ElapsedEventArgs e)
		{							   
			// по таймеру каждые 30 секунд пишем сообщение в лог
			Logger.Info("Hello, world!");			   	   
		}
	}
</pre>
			<h3>Подключение плагина к сервису и отладка</h3>
			<p>
				Как мы уже знаем, плагин - это класс .NET, находящийся в скомпилированной сборке
				(т.е. в файле .dll). Чтобы ваш плагин был загружен сервисом, необходимо положить его
				в папку с плагинами. Путь к папке с плагинами задается в конфигурационном файле сервиса 
				(ThinkingHome.Service.exe.config) в разделе <code>appSettings</code> при помощи 
				параметра с названием <code>"pluginsFolder"</code>.
			</p>
			<pre>
&lt;appSettings>
	&lt;add key="pluginsFolder" value="Plugins"/>
&lt;/appSettings>
</pre>
			<p>
				По умолчанию используется подпапка <em>Plugins</em>, находящаяся в папке, куда был 
				установлен сервис.
			</p>
			<p>
				Внутри папки с плагинами находятся несколько вложенных папок - по одной на каждый плагин.
				Вам нужно создать новую подпапку для своего плагина и положить туда все файлы, необходимые
				для его работы (т.е. саму сборку с плагином и внешние компоненты, которые он использует).
				Т.е. структура папок будет примерно такая:
			</p>
			<pre>
<strong>Program Files (x86)</strong>
└─ <strong>ThinkingHome</strong>
    └─ <strong>service</strong>
        └─ <strong>Plugins</strong>
            ├─ <strong>Plugin.A</strong>
            ├─ <strong>Plugin.B</strong>
            │  ...
            └─ <strong>MyPlugin</strong>
                ├─ MyPlugin.dll
                ├─ ExternalLibrary1.dll
                └─ ExternalLibrary2.dll
</pre>
			<p>
				Для отладки используйте консольное приложение, <em>ThinkingHome.TestConsole.exe</em>,
				которое находится в одной папке с сервисом. Это консольное приложение работает точно
				так же, как сервис, но с ним немного удобнее работать при отладке.
			</p>
			<p>
				Для того, чтобы войти в режим отладки, добавьте в нужное место вызов статического метода 
				<code>Launch()</code> класса <code>System.Diagnostics.Debugger</code> и скомпилируйте
				сборку в режиме <em>Debug</em>. После этого положите скомпилированную DLL в папку с плагинами
				и запустите отладочное консольное приложение. Когда выполнение дойдет до вызова
				<code>Debugger.Launch()</code>, приложение будет остановлено и вы увидите диалоговое окно с 
				предложением запустить отладчик (например, Visual Studio). В отладчике вы увидите написанный
				вами исходный код плагина и сможете выполнить его по шагам.
			</p>
			<pre>
using System.Diagnostics;
...
[Plugin]
public class MyPlugin : Plugin
{
	...

	public void MyMethod(int arg1, int arg2)
	{
		<strong>Debugger.Launch()</strong>;
		
		...
	}	
}
</pre>
			<p>
				В свойствах проекта на вкладке <em>Build</em> можно указать в качестве значения параметра
				<em>Output path</em> путь к папке плагина (например, 
				<em>C:\Program Files (x86)\ThinkingHome\service\Plugins\MyPlugin</em>). После этого на вкладке
				<em>Debug</em> в разделе <em>Start application</em> можно выбрать вариант 
				<em>Start external program</em> и указать путь к тестовому консольному приложению.
				После этого вы сможете запускать отладку из Visual Studio (нажатием кнопки F5). Это очень
				удобный способ работы с проектом, попробуйте его :) 
			</p>
			<h3>Логирование</h3>
			<p>
				Логирование - самый простой способ получить информацию из плагина. Базовый класс
				<code>ThinkingHome.Core.Plugins.Plugin</code> (от которого наследуются все плагины) 
				содержит объект <code>Logger</code>, при помощи методов которого можно записывать 
				сообщения в лог.
			</p>
			<pre>
	Logger.Info("Hello, world!");
	Logger.Error("Error message");
</pre>
			<p>
				По умолчанию лог сохраняется в текстовый файл в папке "Log". Для каждого плагина
				создается отдельный файл,	имя которго соответствует названию плагина. Также 
				лог делится по датам (лог за каждый день сохраняется в отдельном файле).  
			</p>
			<p>
				Для логирования в системе используется библиотека 
				<a href="http://nlog-project.org/" target="_blank">NLog</a>. Настройки логирования
				можно задать в конфигурационном файле приложения (файл ThinkingHome.Service.exe.config
				в корневой директории сервиса). Например, можно настроить, чтобы ошибки сохранялись
				в БД или отправлялись на e-mail.
			</p>
			<h3>Вызов команд плагинов</h3>
			<p>
				Каак мы знаем, каждый плагин - это класс .NET, содержащий некоторый функционал. 
				Из любого плагина можно получить экземпляр любого другого плагина и вызывать его 
				открытые (public) методы. Например, ваш плагин может получить экземпляр плагина, 
				управляющего освещением через noolite и вызвать у него метод выключения света в 
				заданном канале.
			</p>
			<p>
				Получить экземпляр другого плагина можно получить через свойство <code>Context</code>
				базового класса <code>ThinkingHome.Core.Plugins.Plugin</code>. Это свойство содержит специальный 
				объект, реализующий интерфейс <code>ThinkingHome.Core.Plugins.IServiceContext</code>. 
				Для получения экземпляра другого плагина используйте метод <code>GetPlugin&lt;TPlugin></code>. 
				Перед этим необходимо добавить в проект вашего плагина ссылку на сборку, в которой находится 
				используемый плагин.
			</p>
			<pre>
	var noolitePlugin = Context.GetPlugin&lt;NooLitePlugin>(); 
	noolitePlugin.SetLevel(50, 3); // устанавливаем уровень яркости 50 в третьем канале
</pre>
			<p>
				Метод <code>GetAllPlugins</code> возвращает коллекцию всех плагинов, доступных в
			приложении.
			</p>
			<pre>
	// вывод в лог названий всех доступных плагинов  
	foreach (Plugin plugin in Context.GetAllPlugins())
	{
		var typeName = plugin.GetType().Name;
		Logger.Info(typeName);
	}
</pre>

			<h3>Подписка на события плагинов</h3>
			<p>
				Плагины могут подписываться на события друг друга. Например, плагин "будильник"
				может подписаться на событие "срабатывание таймера" плагина "таймер" и, если наступило
				нужное время, подать звуковой сигнал.
			</p>
			<p>
				Плагин, генерирующий событие, определяет у себя коллекцию делегатов - обработчиков
				события. Другие плагины объявляют у себя методы-обработчики для заданного события
				и связывают их с коллекцией делегатов. Связывание происходит при помощи 
				<a href="http://msdn.microsoft.com/ru-ru/library/dd460648%28v=vs.110%29.aspx" target="_blank">MEF</a> (является чатью .NET Framework, начиная с версии 4.0).
			</p>
			<p>
				Для того, чтобы разрешить другим плагинам подписываться на событие, нужно определить
				коллекцию делегатов с нужными параметрами и отметить ее атрибутом 
				<code>System.ComponentModel.Composition.ImportManyAttribute</code>. Для того, чтобы
				в список обработчиков добавлялись только нужные обработчики, а не все методы с такой
				же сигнатурой (такими же типами параметров и возвращаемого значения), укажите для
				атрибута ImportMany уникальный идентификатор (например, сгенерируйте Guid). Ниже
				приведен пример описания коллекции обработчиков для события "срабатывание таймера"
				плагина "таймер" (он генерирует событие "срабатывание таймера" каждые 30 секунд).
			</p>
			<pre>
	// <b>описывается в плагине, генерирующем событие</b>
	[ImportMany("E62C804C-B96B-4CA8-822E-B1725B363534")]
	public Action&lt;DateTime>[] OnEvent { get; set; }
</pre>
			<p>
				Теперь другие плагины могут создавать обработчики для этого события. Сигнатура обработчика
				события задается типом элемента коллекции обработчиков. В нашем примере тип элемента
				- 
				<code>Action&lt;DateTime></code>, значит, обработчик события должен принимать один
				параметр типа <code>DateTime</code> (текущее время) и не возвращать никакого значения
				(void).
			</p>
			<p>
				Ниже приведен пример обработчика события "срабатывание таймера", описанного в предыдущем
				примере. Этот обработчик включает будильник, если настал установленный момент времени.
			</p>
			<pre>
	// <b>описывается в плагине, обрабатывающем событие</b>
	public void OnTimerElapsed(DateTime now)
	{
		var alarmTime = now.Date.AddHours(8).AddMinutes(15);	// время звонка будильника - 8:15
			
		if (now >= alarmTime &&                        // если пришло время звонка будильника
		    now < alarmTime.AddMinutes(5) &&           // и еще не прошло 5 минут
		    lastAlarmTime < alarmTime)                 // и будильник сегодня еще не звонил
		{
			lastAlarmTime = now;
			Context.GetPlugin&lt;SoundPlugin>().PlayAlarmSound();
		}
	}
</pre>
			<p>
				Для того, чтобы этот метод попал в коллекцию обработчиков события, нужно пометить
			его 
			атрибутом <code>System.ComponentModel.Composition.ExportAttribute</code>	и указать
			в его параметрах
			тот же самый идентификатор, который был указан в атрибуте ImportMany (у коллекции
			обработчиков).
			</p>
			<pre>
	[Export("E62C804C-B96B-4CA8-822E-B1725B363534")]
	public void OnTimerElapsed(DateTime now)
	{
		...
	}
</pre>
			<p>
				Для более удобной подписки на события (без необходимости указывать идентификатор)
			можно создать
			собственный атрибут, унаследованный от <code>System.ComponentModel.Composition.ExportAttribute</code>
				и передать нужный идертификатор при вызове базового конструктора.
			</p>
			<pre>
	// собственный атрибут												 
	[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
	public class OnTimerElapsedAttribute : ExportAttribute
	{
		public OnTimerElapsedAttribute()
			: base("E62C804C-B96B-4CA8-822E-B1725B363534")
		{  
		}
	}		
	   
	...
	
	// подписка на событие
	[OnTimerElapsed]
	public void OnTimerElapsed(DateTime now)
	{
		...
	}
</pre>
			<p>
				Итак, мы пометили нужными атрибутами коллекцию делегатов и необходимые методы плагинов.
			При старте сервиса указатели на нужные методы автоматически будут добавлены в коллекцию
			делегатов. После этого остается только вызвать все подписанные методы при возникновении
			нужного события.
			</p>
			<p>
				Для вызова обработчиков события лучше всего воспользоваться методом <code>Run</code>
				из 
			базового класса плагина. В качестве параметров передается сама коллекция делегатов
			и 
			лямбда-выражение, задающее действие над каждым из них (т.е. вызов делегата с нужными
			параметрами). Внутри метод Run проходит в цикле по всем обработчикам и вызывает
			для каждого
			из них выражение, переданное во втором параметре (с обработкой исключений).
			</p>
			<p>
				Пример, приведенный ниже - из плагина "таймер": при срабатывании системного таймера
			вызываются все подписанные обработчики, в каждый из которых передается текущие дата
			и время.
			</p>
			<pre>
	// коллекция обраобтчиков события
	[ImportMany("E62C804C-B96B-4CA8-822E-B1725B363534")]
	public Action&lt;DateTime>[] OnEvent { get; set; }
	
	// инициализируем таймер
	public override void Init()
	{
		timer = new System.Timers.Timer(TIMER_INTERVAL);
		timer.Elapsed += OnTimedEvent;
	}
	
	// при срабатывании таймера вызываем обработчики события
	private void OnTimedEvent(object source, ElapsedEventArgs e)
	{
		var now = DateTime.Now;
		Run(OnEvent, x => x(now));
	}
</pre>
			<h3>Доступ к БД</h3>
			<p>
				Плагины могут хранить свои данные в системной БД. Например, плагин "будильник" может
			хранить там список настроек будильников.
			</p>
			<h4>Создание таблиц</h4>
			<p>
				Плагины могут автоматически создавать себе необходимые таблицы в БД. Для этого используется
				<a href="http://code.google.com/p/ecm7migrator/" target="_blank">ECM7.Migrator</a> - инструмент 
				контроля версий БД. С его помощью можно описать "миграции" - небольшие порции изменений БД. 
				Каждая миграция имеет номер версии, в которой будет находиться БД после ее применения (нумерация 
				версий ведется отдельно по каждому плагину). Мигратор автоматически выполняет миграции в нужной 
				последовательности. При старте сервиса выполняются миграции, описанные в плагинах и 
				автоматически создаются все нужные объекты БД.
			</p>
			<p>
				Каждая "миграция" - это класс .NET, унаследованный от базового класса 
				<code>Migration</code> (нужно добавить ссылку на сборку <code>ECM7.Migrator.Framework.dll</code>) 
				и реализующий его абстрактные методы <code>Apply</code> и <code>Revert</code>.
				В этих методах при помощи специального API описываются изменения БД, необходимые для
				перехода к следующей версии и для отката к изначальной версии. Номер версии задается
				с помощью атрибута <code>MigrationAttribute</code>.
			</p>
			<p>
			</p>
			<pre>
[Migration(1)]
public class Migration01UserScriptTable : Migration
{
	public override void Apply()
	{
		Database.AddTable("Scripts_UserScript",
			new Column("Id", DbType.Guid, ColumnProperty.PrimaryKey, "newid()"),
			new Column("Name", DbType.String.WithSize(200), ColumnProperty.NotNull),
			new Column("Body", DbType.String.WithSize(int.MaxValue), ColumnProperty.NotNull)
		);
	}

	public override void Revert()
	{
		Database.RemoveTable("Scripts_UserScript");
	}
}
</pre>
			<p>
				Внимание, сборка с плагином <strong>обязательно</strong> должна быть помечена атрибутом
				<code>MigrationAssembly</code>, в параметрах которого должно быть указано уникальное 
				"пространство имен" для миграций (в качестве "пространства имен" рекомендуется использовать
				имя сборки). Это нужно, чтобы изменения из разных плагинов выполнялись независимо друг от друга.
				Например:
			</p>
			<pre>
[assembly: MigrationAssembly("ThinkingHome.Plugins.Scripts")]
</pre>
			<h4>Модель данных</h4>
			<p>
				Работа с БД происходит с помощью ORM <a href="http://nhforge.org/" target="_blank">NHibernate</a>. 
				Инфраструктуру для доступа к данным ядро системы инициализирует самостоятельно. В плагине остается 
				только определить классы модели данных и настроить мэппинг полей классов на поля таблиц.
			</p>
			<p>
				Для настройки мэппинга переопределите в своем плагине виртуальный метод <code>InitDbModel</code>.
				В качестве входного параметра этот метод получает экземпляр классса <code>NHibernate.Mapping.ByCode.ModelMapper</code>.
				Вызывая его методы, можно полностью настроить мэппинг для собственной модели. Например,
				плагин "Scripts" настраивает мэппинг для своей модели примерно так:
			</p>
			<pre>
public class ScriptEventHandler
{
	public virtual Guid Id { get; set; }
	...
}

[Plugin]
public class ScriptsPlugin : Plugin
{
	public override void InitDbModel(ModelMapper mapper)
	{
		<strong>mapper.Class&lt;ScriptEventHandler>(cfg => cfg.Table("Scripts_UserScript"));</strong>
		...
	}	
	...
}
</pre>
			<p>
				По умолчанию при мэппинге действуют следующие правила наименования:
			</p>
			<ul>
				<li>Свойство класса, содержащее идентификатор, должно называться "Id" 
					и будет сохраняться в поле "Id" в таблице БД;
				</li>
				<li>Все свойства мэппятся на поля с таким же названием;</li>
				<li>Свойства, содержащие ссылки на другие сущности, мэппятся на поля с названием
					&lt;название свойства> + "Id".
				</li>
			</ul>
			<p>
				<strong>Внимание!</strong> Все свойства классов модели должны быть виртуальными! Это связано с 
				особенностями реализации NHibernate.
			</p>
			<p>Например:</p>
			<pre>
public class ScriptEventHandler
{
	// будет связано с полем <strong>"Id"</strong>
	public virtual Guid <strong>Id</strong> { get; set; }

	// будет связано с полем <strong>"PluginAlias"</strong>
	public virtual string PluginAlias { get; set; }

	// будет связано с полем <strong>"EventAlias"</strong>
	public virtual string EventAlias { get; set; }

	// будет связано с полем <strong>"UserScriptId"</strong>
	public virtual <strong>UserScript</strong> UserScript { get; set; }
}
</pre>
			<p>
				В большинстве случаев, мэппинг полей может происходить по этим правилам автоматически.
				Если необходимо настроить более сложный мэппинг, воспользуйтесь методами объекта 
				<code>ModelMapper</code>.
			</p>
			<h4>Работа с данными</h4>
			<p>
				Для работы с данными необходимо открыть подключение к БД (в терминах NHibernate это называется
				"session"). Для этого нужно вызвать метод <code>ISession OpenSession()</code> у контекста приложения
				(свойство <code>Context</code> базового класса плагина). Метод <code>OpenSession()</code> вернет
				объект, реализующий интерфейс <code>ISession</code>, через методы которого можно работать с БД
				(например, получать данныые из БД или изменять их).
			</p>
			<p>
				Метод <code>ISession.Query&lt;TEntity>()</code> возвращает значение <code>IQueryable&lt;TEntity></code>
				с которым можно дальше работать через Linq. Например, плагин Scripts получает список сценариев следующим
				образом:
			</p>
			<pre>
using (var session = Context.OpenSession())
{
	var list = session.Query&lt;UserScript>().ToArray();

	...
}
</pre>
			<p>
				Для сохранения объектов в БД используйте метод сессии Save, для удаления - метод Delete.
				Ниже приведен пример их использования.
			</p>
			<pre>
using (var session = Context.OpenSession())
{
	// создаем новй объект UserScript
	var newScript = new UserScript 
		{ 
			Id = Guid.NewGuid(), 
			Name = "script name", 
			Body = "script body" 
		};
		
	// сохраняем его в БД
	session.Save(newScript);
	
	// ищем в БД объект с именем "test"
	var scriptForDelete = session
		.Query&lt;UserScript>()
		.FirstOrDefault(s => s.Name == "test");
		
	// удаляем его из БД
	session.Delete(scriptForDelete);
}
</pre>
			<p>
				<strong>Внимание!</strong> Не забываете вызывать метод <code>Dispose()</code> у объекта session 
				(или используйте конструкцию <code>using</code>).
			</p>
			<h3>API стандартных плагинов</h3>
			<p>
				При установке сервиса вместе с ядром системы устанавливаются несколько "стандартных"
				плагинов. Они содержат базовые возможности системы, такие как выполнение сценариев или, 
				например, генерация событий по таймеру.
			</p>
			<h4>Работа с таймером</h4>
			<p>
				Стандартный плагин <code>ThinkingHome.Plugins.Timer</code> позволяет выполнять необходимые
				действия при наступлении некоторого момента времени. Этот плагин генерирует событие 
				"срабатывание таймера" через равные промежутки времени (каждые 30 секунд).
			</p>
			<p>
				Вы можете подписаться на это событие при помощи атрибута 
				<code>ThinkingHome.Plugins.Timer.OnTimerElapsed</code>. Обработчик события
				должен принимать один параметр типа <code>DateTime</code> - в нем будет передаваться
				текущие дата и время. По значению этого параметра можно проверить, наступил ли нужный 
				момент времени. Обработчик не должен возвращать ничего (<code>void</code>).
			</p>
			<pre>
[OnTimerElapsed]
public void MyHandler(DateTime now)
{
	...
}
</pre>
			<h4>Обработка HTTP-запросов</h4>
			<p>
				Стандартный плагин <code>ThinkingHome.Plugins.Listener</code> позволяет вызывать методы других
				плагинов по протоколу HTTP. Listener обрабатывает запросы на порт, указанный в настройках, 
				и перенаправляет их плагинам, для которых они предназначены. Другими словами, с помощью
				плагина Listener другие плагины могут расшаривать свои команды для внешних приложений. 
				Например, веб-консоль работает с плагинами именно таким образом. 
			</p>
			<p>
				Плагин Listener обрабатывает запросы вида: 
				<code>http://localhost:8000/api/<strong>MyPlugin</strong>/<strong>MyHttpCommand</strong></code><br />
				В этом примере:
			</p>
			<ul>
				<li><strong>localhost</strong> - имя или IP-адрес компьютера, на котором работает сервис
				автоматизации;</li>
				<li><strong>8000</strong> - это порт, заданный в настройках плагина "ThinkingHome.Plugins.Listener";
				</li>
				<li><strong>MyPlugin</strong> - <em>имя плагина</em>, которому Listener должен перенаправить
				запрос;</li>
				<li><strong>MyHttpCommand</strong> - <em>название метода</em> которому нужно перенаправить
				запрос.</li>
			</ul>

			<p>
				При получении HTTP-запроса Listener генерирует событие "получен HTTP-запрос" и вызывает 
				обраобтчики, подписанные на это событие. Подписаться на событие можно с помощью
				атрибута <code>ThinkingHome.Plugins.Listener.ExtCommand</code>. Этот атрибут имеет два
				обязательных параметра: "pluginAlias" и "methodAlias". Обработчик события будет
				вызван, если его параметры "pluginAlias" и "methodAlias" соответствуют имени плагина
				и названию метода, указанным в запросе.
			</p>
			<p>
				Например, для обработки запроса 
				<code>http://localhost:8000/api/<strong>MyPlugin</strong>/<strong>MyHttpCommand</strong></code>
				нужно написать примерно такой обработчик:
			</p>
			<pre>
// pluginAlias = "MyPlugin", methodAlias = "MyHttpCommand"
[ExtCommand(<strong>"MyPlugin"</strong>, <strong>"MyHttpCommand"</strong>)]
public object MyHttpHandler(dynamic args)
{
	...
}
</pre>
			<p>
				Обработчик события должен принимать один параметр <code>dynamic</code> (аргументы запроса)
				и должен возвращать значение типа <code>object</code> (будет сериализовано в JSON и возвращено 
				на клиент).
			</p>
			<p>
				Для передачи обработчику аргументов используйте параметр HTTP-запроса с именем 
				<strong>json</strong> (можно передать как в GET, так и в POST запросах).
				Значение этого параметра будет десериализовано в <code>dynamic</code> объект и передано
				обработчику запроса (входной параметр обработчика).
			</p>
			<p>
				Например, для сохранения текста скрипта нужно сделать запрос на адрес 
				<code>http://localhost:8000/api/Scripts/SaveScript</code><br />
				с параметром <code>json={"id":"61c70584-7942-4958-87da-0b469fa6997a","body":"host.logInfo(\"Hello,
				world!\");"}</code>
			</p>
			<p>
				В этом примере запрос будет передан методу <strong>SaveScript</strong> плагина <strong>Scripts</strong>
				с параметрами:
			<br />
				<strong>id</strong> = "61c70584-7942-4958-87da-0b469fa6997a" и <strong>body</strong>
				= "host.logInfo(\"Hello, world!\");".
			</p>
			<p>
				Кроме параметра "json" можно также можно указать необязательный параметр <strong>callback</strong>, 
				задающий название JS функции для обработки результатов запроса (JSONP).
			</p>
			<h4>Управление электроприборами</h4>
			<p>
				Плагин <code>ThinkingHome.Plugins.NooLite.NooLitePlugin</code> позволяет управлять электроприборами
				через систему nooLite и обрабатывать команды пультов nooLite, полученные USB-адаптером RX1164.
			</p>
			<p>
				Для отправки команд силовым блокам nooLite через USB-адаптер PC11xx используйте метод 
				<code>SetLevel</code>. Этот метод получает 2 аргумента: номер канала и уровень яркости, 
				который нужно установить в канале.
			</p>
			<pre>
	// устанавливаем в 7 канале уровень яркости = 90
	Context.GetPlugin&lt;<strong>NooLitePlugin</strong>>().SetLevel(7, 90);
</pre>
			<p>
				Для подписки на событие "получена команда" USB-адаптера RX1164 используйте атрибут
				<code>ThinkingHome.Plugins.NooLite.OnRX1164CommandReceivedAttribute</code>. Обработчики
				этого события получают три аргумента:
			</p>
			<ul>
				<li><code>int cmd</code> - полученная команда (номера команд см. в описании адаптера RX1164);</li>
				<li><code>int channel</code> - номер канала;</li>
				<li><code>byte[] data</code> - данные, переданные с командой (см. описание адаптера RX1164).</li>
			</ul>
			<pre>
[OnRX1164CommandReceived]
public object MyRX1164Handler(int cmd, int channel, byte[] data)
{
	Logger.Info("Получена команда {0} в {1} канале", cmd, channel);
}
</pre>
			<h4>Предоставление доступа сценариям к командам плагинов</h4>
			<p>
				В разделе о сценариях мы видели, что из сценариев можно вызывать методы плагинов. Примерно так:
			</p>
			<pre>
host.getPlugin(<strong>"pluginName"</strong>).executeMethod(<strong>"methodName"</strong>, 3, 0);
</pre>
			<p>
				Таким образом можно вызывать не все методы плагинов, а только те, для которых плагин
				разрешил доступ из сценариев. Чтобы метод вашего плагина можно было вызывать из сценариев,
				необходимо пометить его специальным атрибутом <code>ThinkingHome.Plugins.Scripts.ScriptCommandAttribute</code>.
				Этот атрибут имеет два обязательных параметра: <em>имя плагина</em> и <em>название метода</em>.
				Эти значения будут использоваться в сценариях для вызова методов. В приведенном выше примере
				строка <code>"pluginName"</code> - это имя плагина, а строка <code>"methodName"</code> - 
				название метода. 
			</p>
			<p>
				Например, вот так описан метод <code>setLevel</code> в плагине NooLitePlugin:
			</p>
			<pre>
// имя плагина: <strong>noolite</strong>
// название метода: <strong>setLevel</strong>

[ScriptCommand("noolite", "setLevel")]
public void SetLevel(int channel, int level)
{
	...
}
</pre>
			<p>
				В качестве имени плагина и названия метода можно использовать абсолютно любые строки,
				но старайтесь выбирать их так, чтобы они не повторялись в других плагинах. Если несколько 
				плагинов будут содержать одинаковые пары <em>имя плагина</em> - <em>название метода</em>,
				то при запуске сервиса будет сгенерировано исключение.
			</p>
			<h4>Генерация сценарных событий</h4>
			<p>
				Плагины могут описывать события, в качестве обработчиков которых можно назначить сценарии. 
				Т.е. пользователь может написать сценарий (через UI), зайти в раздел подписки на события 
				(там автоматически отобразятся все доступные для сценариев события плагинов) и указать, 
				при наступлении какого события какие сценарии нужно выполнить.
				Механизм подписки сценариев на события реализован в плагине <code>ThinkingHome.Plugins.Scripts.ScriptsPlugin</code>.
			</p>
			<p>
				Для того, чтобы событие плагина было доступно для сценариев, необходимо для описания коллекции его обработчиков
				использовать специальный делегат <code>ThinkingHome.Plugins.Scripts.ScriptEventHandlerDelegate</code>.
			</p>
			<pre>
public delegate void ScriptEventHandlerDelegate(string pluginAlias, string eventAlias, object[] parameters);
</pre>
			<p>
				Как видите, обработчики этого типа событий получают два строковых параметра и массив объектов.
				Строковые параметры - это название плагина и название события. По их значениям система сможет определить,
				какое событие произошло и какие сценарии нужно запустить. Массив объектов - это 
				аргументы, которые будут переданы в каждый запускаемый сценарий.
			</p>
			<p>
				Кроме использования делегата <code>ScriptEventHandlerDelegate</code>, необходимо пометить
				коллекцию обработчиков специальным атрибутом <code>ThinkingHome.Plugins.Scripts.ScriptEventAttribute</code>
				(<strong>вместо</strong> атрибута <code>ImportMany</code>).
				Этот атрибут имеет два обязательных параметра: <em>имя плагина</em> и <em>название события</em>.
				При возникновении события они будут переданы обработчику в качестве 
				первых двух параметров.
			</p>
			<p>
				Пример описания сценарного события (из плагина ThinkingHome.Plugins.NooLite.NooLitePlugin):
			</p>
			<pre>
[ScriptEvent("noolite", "commandReceived")]
public ScriptEventHandlerDelegate[] OnCommandReceivedForScripts { get; set; }
</pre>
			<p>
				Мы только-что разобрались, как описать коллекцию обработчиков для сценарного события. Плагин 
				Scripts автоматически подпишется на это событие и будет автоматически запускать подписанные 
				на него сценарии.
			</p>
			<p>
				Для запуска обработчиков сценарного события используйте специальный метод-расширение 
				<code>RaiseScriptEvent</code> из базового класса вашего плагина. В этот метод необходимо
				передать лямбда-выражение, указывающее, какую коллекцию обработчиков нужно запустить.
				Остальные параметры будут переданы в запускаемые сценарии. 
			</p>
			<p>
				Например, вот так плагин NooLitePlugin запускает обработчики для события "получена команда
				с адаптера RX1164":
			</p>
			<pre>
void rx1164_CommandReceived(ReceivedCommandData obj)
{
	...
	this.RaiseScriptEvent(x => x.<strong>OnCommandReceivedForScripts</strong>, obj.Cmd, obj.Channel, obj.Data);
}
</pre>
			<p>
				Метод-расширение <code>RaiseScriptEvent</code> отличается от метода <code>Run</code> (котрый мы 
				использовали для генерации остальных событий) тем, что автоматически передаст обработчикам 
				события <em>название плагина</em> и <em>название события</em>, указанные в атрибуте 
				<code>ScriptEvent</code>.
			</p>
		</div>
	</div>
</div>
